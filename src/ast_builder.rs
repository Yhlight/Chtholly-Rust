//! Builds the Abstract Syntax Tree (AST) from a Concrete Syntax Tree (CST) generated by Pest.

use crate::ast::{self, BinaryOperator, Expression, Statement, UnaryOperator};
use crate::parser::Rule;
use pest::iterators::{Pair, Pairs};

pub fn build_ast_from_cst(mut cst: Pairs<Rule>) -> ast::Program {
    let program_node = cst.next().unwrap();
    let mut functions = vec![];
    for pair in program_node.into_inner() {
        match pair.as_rule() {
            Rule::function_definition => functions.push(build_function(pair)),
            Rule::EOI => (),
            _ => unreachable!("Unexpected rule in program: {:?}", pair.as_rule()),
        }
    }
    ast::Program { functions }
}

fn build_function(pair: Pair<Rule>) -> ast::FunctionDefinition {
    let mut inner = pair.into_inner();
    // fn_kw is atomic, so it doesn't have inner pairs.
    // We just need to advance the iterator.
    inner.next(); // Skip fn_kw
    let name = inner.next().unwrap().as_str().to_string();

    let mut next_item = inner.next().unwrap();
    let params = if next_item.as_rule() == Rule::parameter_list {
        let params = build_parameters(next_item);
        next_item = inner.next().unwrap();
        params
    } else {
        vec![]
    };

    let return_type = build_type(next_item);

    let mut body = vec![];
    for stmt_pair in inner {
        if stmt_pair.as_rule() == Rule::statement {
            body.push(build_statement(stmt_pair));
        }
    }

    ast::FunctionDefinition {
        name,
        params,
        return_type,
        body,
    }
}

fn build_parameters(pair: Pair<Rule>) -> Vec<ast::Parameter> {
    pair.into_inner()
        .map(|p| {
            let mut inner = p.into_inner();
            let name = inner.next().unwrap().as_str().to_string();
            let param_type = build_type(inner.next().unwrap());
            ast::Parameter { name, param_type }
        })
        .collect()
}

fn build_type(pair: Pair<Rule>) -> ast::Type {
    let inner_pair = pair.clone().into_inner().next().unwrap_or(pair);
    match inner_pair.as_rule() {
        Rule::type_ident | Rule::ident => ast::Type::Simple(inner_pair.as_str().to_string()),
        Rule::array_type => {
            let mut inner = inner_pair.into_inner();
            let base_type = build_type(inner.next().unwrap());
            ast::Type::Array(Box::new(base_type))
        }
        Rule::generic_type => {
            let mut inner = inner_pair.into_inner();
            let name = inner.next().unwrap().as_str().to_string();
            let args = inner.map(build_type).collect();
            ast::Type::Generic(name, args)
        }
        _ => unreachable!("Unexpected rule in build_type: {:?}", inner_pair.as_rule()),
    }
}

fn build_statement(pair: Pair<Rule>) -> ast::Statement {
    let inner = pair.into_inner().next().unwrap();
    match inner.as_rule() {
        Rule::expression_statement => {
            let expr = build_expression(inner.into_inner());
            Statement::Expression(expr)
        }
        Rule::variable_declaration => {
            Statement::VariableDeclaration(build_variable_declaration(inner))
        }
        _ => unreachable!("Unexpected rule in build_statement: {:?}", inner.as_rule()),
    }
}

fn build_variable_declaration(pair: Pair<Rule>) -> ast::VariableDeclaration {
    let mut inner = pair.into_inner();
    let kw = inner.next().unwrap();
    let is_mutable = kw.as_rule() == Rule::mut_kw;

    let name = inner.next().unwrap().as_str().to_string();

    let mut var_type = None;
    let mut initializer = None;

    if let Some(next_pair) = inner.next() {
        match next_pair.as_rule() {
            Rule::r#type => {
                var_type = Some(build_type(next_pair));
                if let Some(expr_pair) = inner.next() {
                    initializer = Some(build_expression(expr_pair.into_inner()));
                }
            }
            Rule::expression => {
                initializer = Some(build_expression(next_pair.into_inner()));
            }
            _ => unreachable!(
                "Unexpected rule in variable_declaration: {:?}",
                next_pair.as_rule()
            ),
        }
    }

    ast::VariableDeclaration {
        is_mutable,
        name,
        var_type,
        initializer,
    }
}

fn build_expression(mut pairs: Pairs<Rule>) -> Expression {
    build_logical_or(pairs.next().unwrap().into_inner())
}

fn build_logical_or(mut pairs: Pairs<Rule>) -> Expression {
    let mut lhs = build_logical_and(pairs.next().unwrap().into_inner());

    while let Some(op) = pairs.next() {
        let op = match op.as_rule() {
            Rule::or_op => BinaryOperator::LogicalOr,
            _ => unreachable!(),
        };
        let rhs = build_logical_and(pairs.next().unwrap().into_inner());
        lhs = Expression::BinaryExpression {
            op,
            left: Box::new(lhs),
            right: Box::new(rhs),
        };
    }

    lhs
}

fn build_logical_and(mut pairs: Pairs<Rule>) -> Expression {
    let mut lhs = build_comparison(pairs.next().unwrap().into_inner());

    while let Some(op) = pairs.next() {
        let op = match op.as_rule() {
            Rule::and_op => BinaryOperator::LogicalAnd,
            _ => unreachable!(),
        };
        let rhs = build_comparison(pairs.next().unwrap().into_inner());
        lhs = Expression::BinaryExpression {
            op,
            left: Box::new(lhs),
            right: Box::new(rhs),
        };
    }

    lhs
}

fn build_comparison(mut pairs: Pairs<Rule>) -> Expression {
    let mut lhs = build_additive(pairs.next().unwrap().into_inner());

    while let Some(op) = pairs.next() {
        let op = match op.as_rule() {
            Rule::eq_op => BinaryOperator::Equal,
            Rule::neq_op => BinaryOperator::NotEqual,
            Rule::lt_op => BinaryOperator::LessThan,
            Rule::gt_op => BinaryOperator::GreaterThan,
            Rule::lte_op => BinaryOperator::LessThanOrEqual,
            Rule::gte_op => BinaryOperator::GreaterThanOrEqual,
            _ => unreachable!(),
        };
        let rhs = build_additive(pairs.next().unwrap().into_inner());
        lhs = Expression::BinaryExpression {
            op,
            left: Box::new(lhs),
            right: Box::new(rhs),
        };
    }

    lhs
}

fn build_additive(mut pairs: Pairs<Rule>) -> Expression {
    let mut lhs = build_multiplicative(pairs.next().unwrap().into_inner());

    while let Some(op) = pairs.next() {
        let op = match op.as_rule() {
            Rule::add_op => BinaryOperator::Add,
            Rule::sub_op => BinaryOperator::Subtract,
            _ => unreachable!(),
        };
        let rhs = build_multiplicative(pairs.next().unwrap().into_inner());
        lhs = Expression::BinaryExpression {
            op,
            left: Box::new(lhs),
            right: Box::new(rhs),
        };
    }

    lhs
}

fn build_multiplicative(mut pairs: Pairs<Rule>) -> Expression {
    let mut lhs = build_unary(pairs.next().unwrap());

    while let Some(op) = pairs.next() {
        let op = match op.as_rule() {
            Rule::mul_op => BinaryOperator::Multiply,
            Rule::div_op => BinaryOperator::Divide,
            Rule::mod_op => BinaryOperator::Modulo,
            _ => unreachable!(),
        };
        let rhs = build_unary(pairs.next().unwrap());
        lhs = Expression::BinaryExpression {
            op,
            left: Box::new(lhs),
            right: Box::new(rhs),
        };
    }

    lhs
}

fn build_unary(pair: Pair<Rule>) -> Expression {
    let mut inner = pair.into_inner();
    let first = inner.next().unwrap();
    if first.as_rule() == Rule::primary {
        build_primary(first)
    } else {
        let operand = build_primary(inner.next().unwrap());
        Expression::UnaryExpression {
            op: UnaryOperator::Not,
            operand: Box::new(operand),
        }
    }
}

fn build_primary(pair: Pair<Rule>) -> Expression {
    let inner = pair.into_inner().next().unwrap();
    match inner.as_rule() {
        Rule::integer => {
            Expression::IntegerLiteral(inner.as_str().parse().expect("Failed to parse integer"))
        }
        Rule::ident => Expression::Variable(inner.as_str().to_string()),
        Rule::boolean => Expression::BooleanLiteral(inner.as_str().parse().unwrap()),
        Rule::string => {
            let literal = inner.as_str();
            Expression::StringLiteral(literal[1..literal.len() - 1].to_string())
        }
        Rule::function_call => {
            let mut inner_pairs = inner.into_inner();
            let name = inner_pairs.next().unwrap().as_str().to_string();
            let args = inner_pairs
                .next()
                .map(|args_pair| {
                    args_pair
                        .into_inner()
                        .map(|p| build_expression(p.into_inner()))
                        .collect()
                })
                .unwrap_or_else(Vec::new);
            Expression::FunctionCall { name, args }
        }
        Rule::expression => build_expression(inner.into_inner()),
        _ => unreachable!("Unexpected rule in build_primary: {:?}", inner.as_rule()),
    }
}
