//! Builds the Abstract Syntax Tree (AST) from a Concrete Syntax Tree (CST) generated by Pest.

use crate::ast::{self, Expression, Statement};
use crate::parser::Rule;
use pest::iterators::{Pair, Pairs};

pub fn build_ast_from_cst(mut cst: Pairs<Rule>) -> ast::Program {
    let program_node = cst.next().unwrap();
    let mut functions = vec![];
    for pair in program_node.into_inner() {
        match pair.as_rule() {
            Rule::function_definition => functions.push(build_function(pair)),
            Rule::EOI => (),
            _ => unreachable!("Unexpected rule in program: {:?}", pair.as_rule()),
        }
    }
    ast::Program { functions }
}

fn build_function(pair: Pair<Rule>) -> ast::FunctionDefinition {
    let mut inner = pair.into_inner();
    // fn_kw is atomic, so it doesn't have inner pairs.
    // We just need to advance the iterator.
    inner.next(); // Skip fn_kw
    let name = inner.next().unwrap().as_str().to_string();

    let mut next_item = inner.next().unwrap();
    let params = if next_item.as_rule() == Rule::parameter_list {
        let params = build_parameters(next_item);
        next_item = inner.next().unwrap();
        params
    } else {
        vec![]
    };

    let return_type = build_type(next_item);

    let mut body = vec![];
    for stmt_pair in inner {
        if stmt_pair.as_rule() == Rule::statement {
            body.push(build_statement(stmt_pair));
        }
    }

    ast::FunctionDefinition {
        name,
        params,
        return_type,
        body,
    }
}

fn build_parameters(pair: Pair<Rule>) -> Vec<ast::Parameter> {
    pair.into_inner()
        .map(|p| {
            let mut inner = p.into_inner();
            let name = inner.next().unwrap().as_str().to_string();
            let param_type = build_type(inner.next().unwrap());
            ast::Parameter { name, param_type }
        })
        .collect()
}

fn build_type(pair: Pair<Rule>) -> ast::Type {
    let inner_pair = pair.clone().into_inner().next().unwrap_or(pair);
    match inner_pair.as_rule() {
        Rule::type_ident | Rule::ident => ast::Type::Simple(inner_pair.as_str().to_string()),
        Rule::array_type => {
            let mut inner = inner_pair.into_inner();
            let base_type = build_type(inner.next().unwrap());
            ast::Type::Array(Box::new(base_type))
        }
        Rule::generic_type => {
            let mut inner = inner_pair.into_inner();
            let name = inner.next().unwrap().as_str().to_string();
            let args = inner.map(build_type).collect();
            ast::Type::Generic(name, args)
        }
        _ => unreachable!("Unexpected rule in build_type: {:?}", inner_pair.as_rule()),
    }
}

fn build_statement(pair: Pair<Rule>) -> ast::Statement {
    let inner = pair.into_inner().next().unwrap();
    match inner.as_rule() {
        Rule::expression_statement => {
            let expr = build_expression(inner.into_inner().next().unwrap());
            Statement::Expression(expr)
        }
        _ => unreachable!("Unexpected rule in build_statement: {:?}", inner.as_rule()),
    }
}

fn build_expression(pair: Pair<Rule>) -> ast::Expression {
    let inner = pair.into_inner().next().unwrap();
    match inner.as_rule() {
        Rule::integer => {
            Expression::IntegerLiteral(inner.as_str().parse().expect("Failed to parse integer"))
        }
        Rule::string => {
            // Remove quotes from the string literal
            let literal = inner.as_str();
            Expression::StringLiteral(literal[1..literal.len() - 1].to_string())
        }
        Rule::function_call => {
            let mut inner_pairs = inner.into_inner();
            let name = inner_pairs.next().unwrap().as_str().to_string();
            let args = inner_pairs
                .next()
                .map(|args_pair| {
                    args_pair
                        .into_inner()
                        .map(build_expression)
                        .collect()
                })
                .unwrap_or_else(Vec::new);
            Expression::FunctionCall { name, args }
        }
        _ => unreachable!("Unexpected rule in build_expression: {:?}", inner.as_rule()),
    }
}
