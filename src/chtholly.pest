// Chtholly Grammar v2
// ===================

// Silent rules for whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "//" ~ (!("\r" | "\n") ~ ANY)* | "/*" ~ (COMMENT | !"*/" ~ ANY)* ~ "*/" }

// Tokens
ident   = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
integer = @{ ASCII_DIGIT+ }
string  = @{ "\"" ~ ( "\\" ~ ANY | !"\"" ~ ANY)* ~ "\"" }

// Keywords (as atomic rules)
fn_kw    = @{ "fn" }
let_kw   = @{ "let" }
mut_kw   = @{ "mut" }

// Types
// Simplified to handle `string[]` and `Result<i32, SystemError>`
type_ident = { ident } // eg: i32, SystemError, string
generic_type = { type_ident ~ "<" ~ type ~ ("," ~ type)* ~ ">" }
array_type = { type_ident ~ "[]" }
type = { generic_type | array_type | type_ident }


// Main grammar rules
program = { SOI ~ (function_definition | statement)* ~ EOI }

function_definition = {
    fn_kw ~ ident ~ "(" ~ parameter_list? ~ ")" ~ ":" ~ type ~ "{" ~
        (statement)* ~
    "}"
}
parameter_list = { parameter ~ ("," ~ parameter)* }
parameter = { ident ~ ":" ~ type }


variable_declaration = {
    (let_kw | mut_kw) ~ ident ~ (":" ~ type)? ~ ("=" ~ expression)? ~ ";"
}

statement = {
    variable_declaration |
    expression_statement
}

expression_statement = { expression ~ ";" }

expression = { logical_or }
logical_or = { logical_and ~ (or_op ~ logical_and)* }
logical_and = { comparison ~ (and_op ~ comparison)* }
comparison = { term ~ ( (eq_op | neq_op | lt_op | gt_op | lte_op | gte_op) ~ term )* }
term = { factor ~ ( (add_op | sub_op) ~ factor )* }
factor = { unary ~ ( (mul_op | div_op | mod_op) ~ unary )* }
unary = { not_op? ~ primary }
primary = { integer | string | boolean | function_call | ident | "(" ~ expression ~ ")" }

boolean = { "true" | "false" }

add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "/" }
mod_op = { "%" }

eq_op = { "==" }
neq_op = { "!=" }
lt_op = { "<" }
gt_op = { ">" }
lte_op = { "<=" }
gte_op = { ">=" }

not_op = { "!" }
and_op = { "&&" }
or_op = { "||" }

function_call = { ident ~ "(" ~ argument_list? ~ ")" }
argument_list = { expression ~ ("," ~ expression)* }
