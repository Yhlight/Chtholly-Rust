# Chtholly 编译器开发路线图 (RoadMap)

## 1. 项目愿景与方法论

*   **愿景**: 创建一个遵循 Chtholly 语言规范（`Chtholly.md`）的编译器。该编译器应具备高性能、编译期安全、代码简洁的特点，并利用 Rust + LLVM 17 的强大能力，实现零成本抽象和现代化的资源管理。
*   **方法论**:
    *   **Scrum**: 项目将以一系列的“冲刺”（Sprint）形式进行，每个冲刺都专注于交付一小部分可用的、增量的功能。
    *   **TDD (测试驱动开发)**: 每个功能在实现前都将编写对应的测试用例。代码的正确性由测试来保证，以实现稳定、可靠的增量开发并防止回归。
*   **进度跟踪**: 本文档（`RoadMap.md`）是项目进度的唯一事实来源。每个任务完成后，其状态都将在此更新。

---

## 2. 产品待办清单 (Product Backlog)

我们将整个开发过程分解为多个冲刺，循序渐进地实现 Chtholly 语言的全部功能。

### Sprint 0: 项目奠基与“Hello, World!”

*   **目标**: 搭建完整的开发环境与项目骨架，完成最简程序的编译与执行。
*   **状态**: ⏳ **进行中**
*   **任务列表**:
    *   [ ] **环境配置**: 确认 Rust 与 LLVM 17 环境已按 `agents.md` 要求配置完毕。
    *   [ ] **项目初始化**: 使用 `cargo new chtholly_compiler` 创建 Rust 项目。
    *   [ ] **版本控制**: 创建 `.gitignore` 文件，忽略 `target/` 目录及其他构建产物。
    *   [ ] **依赖引入**: 在 `Cargo.toml` 中添加 `llvm-sys` 等必要的 LLVM 依赖。
    *   [ ] **模块化结构**: 创建编译器核心模块目录：`src/lexer`, `src/parser`, `src/ast`, `src/codegen`, `src/errors`。
    *   [ ] **最小化实现**:
        *   硬编码一个代表 `fn main(): i32 { return 0; }` 的 AST。
        *   实现一个最基础的 CodeGen，将此 AST 翻译为 LLVM IR。
        *   实现编译流程，生成可执行文件并验证其返回值为 0。
    *   [ ] **测试框架**: 搭建单元测试和集成测试环境。

### Sprint 1: 词法分析器 (Lexer)

*   **目标**: 实现一个能够将 Chtholly 源代码正确分解为 Token 流的词法分析器。
*   **状态**: 📋 **待办**
*   **任务列表**:
    *   [ ] **Token 定义**: 定义语言的所有 Token 类型（关键字, 标识符, 字面量, 运算符, 分隔符）。
    *   [ ] **核心 Tokenizer**: 实现对数字、标识符和各种符号的识别。
    *   [ ] **注释处理**: 支持 `//` 单行注释和 `/* ... */` 多行注释的忽略。
    *   [ ] **字面量支持**: 支持字符串字面量 (`"..."`) 和字符字面量 (`'...'`) 的解析。
    *   [ ] **TDD**: 为 Lexer 编写全面的单元测试，覆盖所有 Token 类型和边界情况。

### Sprint 2: 语法分析器 (Parser) 与 AST (核心语法)

*   **目标**: 实现一个能够消费 Token 流并构建出抽象语法树（AST）的语法分析器。
*   **状态**: 📋 **待办**
*   **任务列表**:
    *   [ ] **AST 结构**: 定义核心语言结构的 AST 节点（函数定义, 语句, 表达式等）。
    *   [ ] **函数解析**: 实现对函数定义（`fn ...`）的解析。
    *   [ ] **变量声明**: 实现对 `let` 和 `mut` 变量声明的解析，包括类型注解和初始值。
    *   [ ] **基础表达式**: 实现对数字字面量、变量引用等基础表达式的解析。
    *   [ ] **TDD**: 为 Parser 编写单元测试，验证 Token 序列能被正确转换为 AST。

### Sprint 3: 代码生成 (CodeGen) - 基础功能

*   **目标**: 将基础的 AST 结构翻译为 LLVM IR，实现变量和基本函数的代码生成。
*   **状态**: 📋 **待办**
*   **任务列表**:
    *   [ ] **LLVM 初始化**: 设置 LLVM 的 Context, Module, 和 IRBuilder。
    *   [ ] **函数生成**: 实现将函数定义的 AST 节点翻译为 LLVM Function。
    *   [ ] **变量生成**: 实现 `let` 声明的 `alloca` 指令（栈分配）。
    *   [ ] **第一个程序**: 整合 Lexer, Parser, CodeGen，成功编译并运行第一个简单的 Chtholly 程序（例如：`fn main(): i32 { let a = 10; return a; }`）。
    *   [ ] **TDD**: 为 CodeGen 编写测试，验证 AST 能生成预期的 LLVM IR。

### Sprint 4: 表达式与运算符

*   **目标**: 完整支持 Chtholly 的各类运算符和表达式。
*   **状态**: 📋 **待办**
*   **任务列表**:
    *   [ ] **二元运算符**: 扩展 Parser 和 CodeGen 以支持算术 (`+`, `-`, `*`, `/`, `%`) 和比较 (`==`, `!=`, `>`, `<`, `>=`, `<=`) 运算符。
    *   [ ] **逻辑运算符**: 支持 `&&` 和 `||`。
    *   [ ] **一元运算符**: 支持 `!` 和 `-` (负号)。
    *   [ ] **优先级与结合性**: 在 Parser 中正确处理运算符的优先级和结合性（如使用 Pratt Parsing）。
    *   [ ] **TDD**: 编写覆盖所有运算符组合和复杂表达式的测试。

### Sprint 5: 控制流 - 条件与作用域

*   **目标**: 实现 `if-else` 条件语句和正确的词法作用域。
*   **状态**: 📋 **待办**
*   **任务列表**:
    *   [ ] **If-Else 解析**: 扩展 AST 和 Parser 以支持 `if-else` 结构。
    *   [ ] **符号表**: 设计并实现一个符号表，用于管理变量的声明、作用域和生命周期。
    *   [ ] **条件分支生成**: 扩展 CodeGen 以使用 LLVM 的基本块（Basic Blocks）和分支指令（`br`）来生成条件跳转逻辑。
    *   [ ] **TDD**: 编写测试用例，验证条件逻辑的正确性以及变量作用域（包括变量遮蔽）规则。

### Sprint 6: 控制流 - 循环

*   **目标**: 实现 `while`, C-style `for`, `do-while` 循环结构。
*   **状态**: 📋 **待办**
*   **任务列表**:
    *   [ ] **循环解析**: 扩展 AST 和 Parser 以支持所有循环类型。
    *   [ ] **循环生成**: 扩展 CodeGen 以使用 LLVM 基本块构建循环结构。
    *   [ ] **控制关键字**: 实现 `break` 和 `continue` 语句的跳转逻辑。
    *   [ ] **TDD**: 为每种循环编写测试，包括空循环、单次循环和嵌套循环。

---

### 后续冲刺规划 (高阶功能)

*   **Sprint 7: 函数调用与所有权 (Part 1)**
    *   实现用户定义函数、参数传递、返回值。
    *   引入类型检查，开始构建所有权系统的基础（移动语义）。

*   **Sprint 8: 复合类型 - Struct 与静态数组**
    *   实现 `struct` 定义、实例化（聚合与指定初始化）、成员访问。
    *   实现静态数组（`i32[4]`）的定义与访问。

*   **Sprint 9: 复合类型 - Class (Part 1)**
    *   实现 `class` 定义、成员变量、访问修饰符 (`public`/`private`)。
    *   实现构造函数和 `Self` 关键字。

*   **Sprint 10: 所有权与借用 (Part 2)**
    *   实现完整的借用检查器（Borrow Checker），强制执行 `&` 和 `&mut` 的规则。
    *   在编译期检测悬垂引用、二次释放等内存安全问题。

*   **Sprint 11: 高级特性 - Enum 与 `switch`**
    *   实现带有关联数据的 `enum`。
    *   实现强大的 `switch-case` 结构，支持对 `enum` 的模式匹配和解构。

*   **Sprint 12: 泛型**
    *   实现泛型函数和泛型类。
    *   通过单态化（Monomorphization）在 CodeGen 阶段处理泛型实例化。
    *   支持泛型特化。

*   **Sprint 13: 模块系统与错误处理**
    *   实现 `import`, `use`, `package` 模块系统。
    *   实现 `Result<T, E>` 内置类型和 `?` 错误传播操作符。

*   **Sprint 14: 约束 (Request) 与迭代器**
    *   实现 `request` 约束系统（类似 Trait/Interface）。
    *   实现关联类型和关联约束。
    *   实现内置的 `iterator` 约束，并在此基础上实现 `foreach` 循环。

*   **Sprint 15+: 标准库与生态**
    *   扩展标准库（IO, 集合, 字符串处理等）。
    *   `optional<T>` 类型。
    *   Lambda 表达式与闭包。
    *   析构函数 (`~`)。
    *   构建一个简单的包管理器。
