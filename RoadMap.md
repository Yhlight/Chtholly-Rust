# Chtholly 语言开发路线图

## 核心理念

Chtholly 是一门旨在实现**编译期安全**与**高性能**的系统编程语言。其核心设计哲学围绕以下几点展开：

- **所有权 (Ownership):** 编译期强制的内存安全保障，杜绝野指针和二次释放。
- **借用检查 (Borrow Checking):** 严格的读写互斥规则，根除数据竞争。
- **自动生命周期管理 (Automatic Lifetime Management):** 智能的生命周期推导，减轻开发者心智负担。
- **编译期体系 (Compile-Time System):** 强大的 `const` 系统，将计算前置到编译期，实现零运行时开销。

本文档将详细记录 Chtholly 语言的开发进度，并确保每一个功能的实现都经过充分的测试驱动开发（TDD）。

---

## 第一阶段：基础架构与核心语法

此阶段的目标是搭建 Chtholly 语言的骨架，实现最基础的语法和编译流程。

- **[ ] 1. 项目初始化**
    - [x] 创建 `RoadMap.md`
    - [x] 搭建 CMake 构建系统
    - [x] 配置 LLVM 后端依赖
    - [x] 创建 `.gitignore` 文件，忽略构建产物

- **[ ] 2. 词法分析 (Lexer)**
    - [ ] 实现对基本 Token 的识别（关键字, 标识符, 操作符, 字面量）
    - [ ] 编写单元测试，覆盖所有 Token 类型

- **[ ] 3. 语法分析 (Parser)**
    - [ ] 定义抽象语法树 (AST) 结构
    - [ ] 实现主函数 `fn main()` 的解析
    - [ ] 实现变量声明 (`let`, `let mut`) 的解析
    - [ ] 实现基本数据类型 (`i32`, `f64`, `bool`, `char`, `string`) 的解析
    - [ ] 编写单元测试，确保 AST 生成的正确性

- **[ ] 4. LLVM IR 生成**
    - [ ] 实现 AST 到 LLVM IR 的转换
    - [ ] 实现最简单的 "Hello, World!" 程序编译
    - [ ] 编写端到端测试，验证编译产物的正确性

---

## 第二阶段：所有权与借用系统

此阶段是 Chtholly 的核心，我们将实现其内存安全的关键特性。

- **[ ] 1. 所有权系统 (Ownership)**
    - [ ] 在 AST 和符号表中引入所有权信息
    - [ ] 实现**移动语义 (Move Semantics)**
        - [ ] 在变量赋值时转移所有权
        - [ ] 在函数传参时转移所有权
        - [ ] 被移动的变量在编译期标记为不可用
    - [ ] 实现 `Copy` Trait，支持基本类型的按位复制
    - [ ] 编写测试用例，覆盖所有权转移和 `Copy` 行为

- **[ ] 2. 借用与引用 (Borrowing & References)**
    - [ ] 实现不可变引用 `&` 和可变引用 `&mut` 的解析
    - [ ] 在符号表中跟踪借用信息
    - [ ] 实现**借用规则**的静态检查：
        - [ ] 允许多个共享引用 (`&`)
        - [ ] 只允许一个可变引用 (`&mut`)
        - [ ] 可变引用与任何其他引用互斥
    - [ ] 编写测试用例，覆盖合法的和非法的借用场景

- **[ ] 3. 生命周期管理 (Lifetime Management)**
    - [ ] 实现**智能生命周期省略**规则
    - [ ] 在函数和数据结构中引入生命周期参数
    - [ ] 实现生命周期检查，防止悬垂引用
    - [ ] 编写测试用例，确保引用的生命周期不超过其指向的数据

---

## 第三阶段：高级数据结构与功能

此阶段将丰富 Chtholly 的语言功能，使其更具表达力。

- **[ ] 1. 类 (Class) 与结构体 (Struct)**
    - [ ] 实现 `class` 和 `struct` 的定义解析
    - [ ] 实现成员变量和成员函数的解析
    - [ ] 实现构造函数和析构函数
    - [ ] 实现 `self`, `&self`, `&mut self` 语义
    - [ ] 实现权限修饰符 (`public`, `private`)
    - [ ] 编写测试用例，覆盖类的完整生命周期

- **[ ] 2. 枚举 (Enum)**
    - [ ] 实现 `enum` 的定义和使用
    - [ ] 支持带状态的枚举
    - [ ] 实现枚举的自动解构
    - [ ] 编写测试用例

- **[ ] 3. 模块系统 (Module System)**
    - [ ] 实现 `import` 和 `use` 语句
    - [ ] 实现基于文件的模块解析
    - [ ] 实现命名空间和别名
    - [ ] 编写测试用例

- **[ ] 4. 错误处理 (Error Handling)**
    - [ ] 实现 `Result<T, E>` 枚举
    - [ ] 实现 `?` 操作符用于错误传播
    - [ ] 编写测试用例

---

## 第四阶段：编译期编程体系

此阶段将实现 Chtholly 的零成本抽象核心——编译期编程。

- **[ ] 1. `const` 常量**
    - [ ] 实现 `const` 常量的定义和求值
    - [ ] 确保 `const` 表达式在编译期完成计算

- **[ ] 2. `const fn` 编译期函数**
    - [ ] 实现 `const fn` 的定义和调用
    - [ ] 限制 `const fn` 内部的副作用
    - [ ] 允许 `const fn` 在运行时作为普通函数使用

- **[ ] 3. `const struct` 常结构体**
    - [ ] 实现 `const struct` 的定义
    - [ ] 确保常结构体在编译期使用，不产生运行时开销

- **[ ] 4. 编译期错误处理**
    - [ ] 扩展 `Result<T, E>` 到编译期
    - [ ] 强制在编译期处理 `const fn` 返回的 `Err`

- **[ ] 5. 编写全面的编译期编程测试**

---

## 第五阶段：生态与未来

- **[ ] 标准库建设**
- **[ ] 包管理器**
- **[ ] 语言文档完善**
